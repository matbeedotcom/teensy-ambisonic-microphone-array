# Configuration file for Teensy 4.1 Tetrahedral 4-channel Microphone Array
# Matches mechanical/tetrahedron_frame.scad with 43.3mm radius, 70.7mm edges

version = "2.1";

# Raw audio input from Teensy USB audio interface
 raw: {
      fS = 44100;
      hopSize = 512;
      nBits = 32;  # Changed from 16 to match WASAPI device
      nChannels = 4;

    # Input from Teensy USB audio device via WASAPI
    interface: {
        type = "wasapi";
        devicename = "Teensy Audio 4CH";  # WASAPI device name
    }
}

# Channel mapping for 4-channel array
mapping:
{
    map: (0, 1, 2, 3);
}

# General configuration for tetrahedral array
general:
{
    
    epsilon = 1E-12;

    size: 
    {
        hopSize = 512;
        frameSize = 1024;
    };
    
    samplerate:
    {
        mu = 44100;
        sigma2 = 0.01;
    };

    speedofsound:
    {
        mu = 343.0;
        sigma2 = 25.0;
    };

    # Tetrahedral microphone positions (meters)
    # Based on array_geometry.json: 25mm from center = 0.025m
    # Regular tetrahedron with vertices at:
    # [0.025, 0.025, 0.025], [0.025, -0.025, -0.025], 
    # [-0.025, 0.025, -0.025], [-0.025, -0.025, 0.025]
    mics = (
        
        # Microphone 0 - Vertex 0 (+X,+Y,+Z)
        { 
            mu = ( +0.025, +0.025, +0.025 ); 
            sigma2 = ( +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000 );
            direction = ( +0.577, +0.577, +0.577 );  # Outward normal
            angle = ( 80.0, 90.0 );
        },

        # Microphone 1 - Vertex 1 (+X,-Y,-Z)
        { 
            mu = ( +0.025, -0.025, -0.025 ); 
            sigma2 = ( +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000 );
            direction = ( +0.577, -0.577, -0.577 );  # Outward normal
            angle = ( 80.0, 90.0 );
        },

        # Microphone 2 - Vertex 2 (-X,+Y,-Z)
        { 
            mu = ( -0.025, +0.025, -0.025 ); 
            sigma2 = ( +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000 );
            direction = ( -0.577, +0.577, -0.577 );  # Outward normal
            angle = ( 80.0, 90.0 );
        },

        # Microphone 3 - Vertex 3 (-X,-Y,+Z)
        { 
            mu = ( -0.025, -0.025, +0.025 ); 
            sigma2 = ( +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000 );
            direction = ( -0.577, -0.577, +0.577 );  # Outward normal
            angle = ( 80.0, 90.0 );
        }
        
    );

    # Full 3D spatial coverage
    spatialfilters = (
        {
            direction = ( +0.000, +0.000, +1.000 );
            angle = (180.0, 180.0);  # Full sphere coverage
        }
    );  

    nThetas = 360;  # Balanced resolution for 3D localization (was 360)
    gainMin = 0.25;

};

# Stationary noise estimation
sne:
{
    
    b = 3;
    alphaS = 0.1;
    L = 150;
    delta = 3.0;
    alphaD = 0.1;

}

# Sound Source Localization
ssl:
{

    nPots = 4;  # Matches 4-channel array - can detect up to 4 simultaneous sources
    nMatches = 10;
    probMin = 0.3;  # Reduced from 0.5 - detect weaker/secondary sources more easily
    nRefinedLevels = 2;  # More refinement for 3D
    interpRate = 4;

    # Moderate-resolution scanning for 3D tetrahedral array
    # Lower levels for faster initialization and real-time processing
    scans = (
        { level = 2; delta = -1; },
        { level = 4; delta = -1; }
    );

    potential: {
        format = "json";
        interface: {
            type = "socket";
            ip = "127.0.0.1";
            port = 9001;
        };
    };

};

# Sound Source Tracking
sst:
{  

    # Mode is either "kalman" or "particle"

    mode = "kalman";

    # Add is either "static" or "dynamic"

    add = "dynamic";

    # Parameters used by both the Kalman and particle filter

    active = (
        { weight = 1.0; mu = 0.3; sigma2 = 0.0025 }
    );

    inactive = (
        { weight = 1.0; mu = 0.15; sigma2 = 0.0025 }
    );

    sigmaR2_prob = 0.01;  # Increased from 0.0025 - allow more spatial uncertainty
    sigmaR2_active = 0.04;  # Increased from 0.0225 - wider active region
    sigmaR2_target = 0.01;  # Increased from 0.0025 - more tolerant positioning
    Pfalse = 0.05;  # Reduced from 0.1 - fewer false positives
    Pnew = 0.4;  # Increased from 0.1 - much more likely to create new tracks
    Ptrack = 0.55;  # Reduced from 0.8 - balance between tracking and new sources

    theta_new = 0.5;  # Reduced from 0.9 - easier to create new tracks
    N_prob = 3;  # Reduced from 5 - faster track confirmation
    theta_prob = 0.6;  # Reduced from 0.8 - lower threshold
    N_inactive = ( 50, 75, 100, 125 );  # Reduced from (150,200,250,250) - faster timeout
    theta_inactive = 0.8;  # Reduced from 0.9 - remove inactive tracks sooner

    # Parameters used by the Kalman filter only

    kalman: {

        sigmaQ = 0.001;
        
    };
   
    # Parameters used by the particle filter only

    particle: {

        nParticles = 1000;
        st_alpha = 2.0;
        st_beta = 0.04;
        st_ratio = 0.5;
        ve_alpha = 0.05;
        ve_beta = 0.2;
        ve_ratio = 0.3;
        ac_alpha = 0.5;
        ac_beta = 0.2;
        ac_ratio = 0.2;
        Nmin = 0.7;

    };

    target: ();

    tracked: {
        format = "json";
        interface: {
            type = "socket";
            ip = "127.0.0.1";
            port = 9000;
        };
    };

}

sss:
{
    
    # Mode is either "dds", "dgss" or "dmvdr"
    # dds = Delay-and-Sum (simple beamforming)
    # dgss = Geometric Source Separation (better for small arrays)
    # dmvdr = Minimum Variance Distortionless Response (needs more mics)

    mode_sep = "dgss";  # Changed from "dds" - better for small arrays
    mode_pf = "ms";

    gain_sep = 1.0;
    gain_pf = 1.0;  # Minimal amplification - preserve separated quality

    dds: {

    };

    dgss: {

        mu = 0.01;
        lambda = 0.5;

    };

    dmvdr: {

    };

    ms: {

        alphaPmin = 0.15;  # Very conservative noise estimation
        eta = 0.3;  # Reduced - less aggressive suppression
        alphaZ = 0.9;  # Increased - slower adaptation
        thetaWin = 0.7;  # Very wide acceptance window
        alphaWin = 0.7;  # Very smooth transitions
        maxAbsenceProb = 0.7;  # More confident about presence
        Gmin = 0.1;  # Higher noise floor - preserve more signal
        winSizeLocal = 7;  # More temporal smoothing
        winSizeGlobal = 15;
        winSizeFrame = 256;

    };

    ss: {

        Gmin = 0.1;  # Much higher noise floor
        Gmid = 0.7;  # Smoother transition
        Gslope = 3.0;  # Very gentle rolloff

    }

    separated: {

        fS = 44100;
        hopSize = 1024;
        nBits = 16;        

        interface: {
            type = "socket";
            ip = "127.0.0.1";
            port = 10000;
        }        

    };  

    postfiltered: {

        fS = 44100;
        hopSize = 512;
        nBits = 16;

        # interface: { # Enable post-filtered output
        #     type = "file";
        #     path = "postfiltered.raw";
        # }
        interface: {
            type = "socket";
            ip = "127.0.0.1";
            port = 10010;
        }
    };

}

classify:
{
    
    frameSize = 1024;
    winSize = 3;
    tauMin = 32;
    tauMax = 200;
    deltaTauMax = 7;
    alpha = 0.3;
    gamma = 0.05;
    phiMin = 0.15;
    r0 = 0.2;    

    category: {

        format = "json";

        interface: {
            type = "terminal";
        }

    }

}